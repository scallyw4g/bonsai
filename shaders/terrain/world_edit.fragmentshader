uniform  v3 WorldspaceChunkBasis;
uniform  v3 ChunkResolution; // TODO(Jesse): Make this a scalar?

uniform int BrushType;
uniform int BlendMode;
uniform int ColorMode;
uniform int ValueModifiers;

uniform int GenerateNormals;

uniform f32 Hollow;
uniform f32 ValueBias;

uniform v3 Axis;

//
// Clipping params
//
uniform v3 ChunkRelEditMin;
uniform v3 ChunkRelEditMax;


//
// Shape params
//
uniform s32  ShapeType; // shape_type
uniform mat4 RotTransform;
uniform f32  Rounding;
uniform  v3  Stretch;
uniform  v3  Repeat;

//
// Rect Params
//

uniform v3 RectDim;

//
// Sphere Params
//
uniform  v3 EditRelativeSphereCenter;
uniform f32 Radius;

//
// Cylinder Params
//

uniform r32 Height;

//
// Plane Params
//
uniform v3 PlaneNormal;
uniform f32 Planed;
uniform f32 PlaneRadius;

//
// Torus Params
//

uniform f32 MinorRadius;




//
// Noise params
//
uniform  int NoiseType;
uniform   v3 RGBColor;
uniform   v3 Period;
uniform  f32 Threshold;
uniform bool Invert;

//
// Voronoi Params
//
uniform f32 Squareness; // 0 == not square, 1 == square



uniform       int SampleInputTex;
uniform sampler2D InputTex;

uniform       int SampleBlendTex;
uniform sampler2D BlendTex;
uniform int BlendTexBlendMode;

in vec2 UV;
out vec4 Output;

r32 DistanceToPlane(v3 PlaneNormal, f32 Planed, v3 P)
{
  r32 a = PlaneNormal.x;
  r32 b = PlaneNormal.y;
  r32 c = PlaneNormal.z;

  r32 d = Planed;

  r32 Distance = a*P.x + b*P.y + c*P.z + d;
  return Distance;
}

f32 iq_sdSphere(v3 p, f32 r)
{
  return length(p) - r;
}

// p == sample point
// b == box dimension
//
f32 iq_sdBox(vec3 p, vec3 b)
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// p == sample point
// h == height
// r == radius
//
float iq_sdCappedCylinder( vec3 p, float h, float r )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float iq_sdCylinder( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

// p == sample point
// a == start point
// b == end point
// r == radius
float iq_sdRoundedLine( vec3 p, vec3 a, vec3 b, float r )
{
  vec3 pa = p - a, ba = b - a;
  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
  return length( pa - ba*h ) - r;
}

// p   == sample point
// t.x == major radius
// t.y == minor radius
//
float iq_sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float iq_sdPyramid( vec3 p, float h )
{
  // NOTE(Jesse): iq uses y-up, so we flip y and z
  f32 z = p.z;
  f32 y = p.y;

  p.z = y;
  p.y = z;


  float m2 = h*h + 0.25;

  p.xz = abs(p.xz);
  p.xz = (p.z>p.x) ? p.zx : p.xz;
  p.xz -= 0.5;

  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);

  float s = max(-q.x,0.0);
  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );

  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;
  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);

  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);

  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));
}


// p == sample point
// h == stretch vector
vec4 iq_opElongate( vec3 p, vec3 h )
{
  // faster, but produces zero in the interior elongated box
  /* return vec4( p-clamp(p,-h,h), 0.0 ); */

  vec3 q = abs(p)-h;
  return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );
}

// p == sample point
// s == spacing between instances
//
v3 iq_opRepetition( v3 p, v3 s )
{
    vec3 q = p - s*round(p/s);
    return q;
}

v4 DoInputTransforms(v3 p, mat3 RotationTransform, v3 Stretch, v3 Repeat)
{
  p *= RotationTransform;

  if (length(Repeat) > 0.f)
  {
    p  = iq_opRepetition(p, Repeat);
  }

  v4 w  = iq_opElongate(p, Stretch);
  return w;
}

#if 1
f32 IQSampleToBonsaiSample(f32 IQSample, f32 Rad)
{
  return (1.f-IQSample)/Rad;
}
#else
f32 IQSampleToBonsaiSample(f32 IQSample, f32 Rad)
{
  return (1.f-IQSample);
}
#endif

// Blend Value
//
void BlendSample(
    int Mode,
    inout f32 Accumulator, inout v3 ColorValue,
    inout f32  ThisSample,    in v3 ColorSample )
{
  switch (Mode)
  {
    case 0: // WorldEdit_Mode_Additive
    {
      if (ThisSample > 0.f)
      {
        Accumulator = Accumulator + ThisSample;
      }
    } break;

    case 1: // WorldEdit_Mode_Subtractive
    {
      if (ThisSample > 0.f)
      {
        Accumulator = Accumulator - ThisSample;
      }
    } break;
 
    case 2: // WorldEdit_Mode_Union
    {
      Accumulator = max(Accumulator, ThisSample);
    } break;

    case 3: // WorldEdit_Mode_Intersection
    {
      Accumulator = min(Accumulator, ThisSample);
    } break;

    case 4: // WorldEdit_Mode_Difference
    {
      // TODO(Jesse): This is wack.  I tried a bunch of other formulation that
      // I think should have worked, but coudn't figure it out..
      if (Accumulator > 0.f && ThisSample > 0.f)
      {
        Accumulator *= -1.f;
      }
      /* Accumulator = max(-1.f*Accumulator, ThisSample); */
      /* Accumulator = sign(-ThisSample) * Accumulator; */
      /* Accumulator = min(Accumulator, -(ThisSample+0.00001f)); */
    } break;

    case 5: // WorldEdit_Mode_Multiply
    {
      Accumulator = Accumulator * ThisSample;
    } break;

    case 6: // WorldEdit_Mode_Disabled
    { ThisSample = 0.f; } break;
  }


  // Blend Color
  //
  switch (ColorMode)
  {
    case 0: // WorldEdit_ColorBlendMode_ValuePositive
    { if (ThisSample > 0.f) { ColorValue = ColorSample; } } break;

    case 1: // WorldEdit_ColorBlendMode_ValueNegative
    { if (ThisSample < 0.f) { ColorValue = ColorSample; } } break;
 
    case 2: // WorldEdit_ColorBlendMode_Surface
    {
      /* if (InitialAccumulator <= 0.f) */
      /* { */
      /*   if (Accumulator > 0.f) */
      /*   { */ 
      /*     ColorValue = ColorSample; */
      /*     /1* ColorValue = ColorSample * (InitialSample); *1/ */
      /*   } */
      /* } */
    } break;
    /* { ColorValue = ColorValue + ColorSample; } break; */

  }
}

float iq_opOnion( in float sdf, in float thickness )
{
    return abs(sdf)-thickness;
}

void main()
{
  v4 TexLookup = vec4(0);
  if (SampleInputTex > 0)
  {
    TexLookup = texelFetch(InputTex, ivec2(gl_FragCoord.xy), 0);
  }

  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = TexLookup.rgb;

  f32  InitialAccumulator = TexLookup.a;
  f32  Accumulator = TexLookup.a;

  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));
  v3 xyz = V3(x,y,z) * ChunkResolution;

  mat3 RotMatrix = mat3(RotTransform);

  // TODO(Jesse): I have no idea why this works out to > Min and <= Max.  I
  // think it should be >= Min and < Max .. but I'm just going to leave it for now..
  if (
      xyz.x > ChunkRelEditMin.x &&
      xyz.y > ChunkRelEditMin.y &&
      xyz.z > ChunkRelEditMin.z &&

      xyz.x <= ChunkRelEditMax.x &&
      xyz.y <= ChunkRelEditMax.y &&
      xyz.z <= ChunkRelEditMax.z  )
  {
    v3 Basis = WorldspaceChunkBasis + xyz;
    v3 EditRelxyz = xyz - ChunkRelEditMin;
    v3 EditDim = ChunkRelEditMax-ChunkRelEditMin;
    v3 EditRad = EditDim/2.f;


    {
      v3 ColorSample = RGBColor;
      f32 InitialSample = 0.f;

      s32 Octaves = 1;
      switch (BrushType)
      {
        case 0: // BrushLayerType_Noise
        {
          v3 NoiseBasis = Basis / Period;
          switch (NoiseType)
          {
            case 0: // NoiseType_Perlin:
            {
              InitialSample = value_noise_derivs(NoiseBasis).x;
            } break;

            case 1: // NoiseType_Voronoi:
            {
              InitialSample = voronoi_noise(NoiseBasis, Squareness).x;
            } break;

            case 2: // NoiseType_White:
            {
              InitialSample = white_noise(NoiseBasis);
            } break;
          }

          break;
        }

        case 1: // BrushLayerType_Shape
        {
          switch (ShapeType)
          {
            // ShapeType_Rect
            case 0:
            {
              v3 BoxR = RectDim/2.f;
              if (length(BoxR) > 0.f)
              {
              }
              else
              {
                BoxR = EditDim;
              }

              v3 Center = EditDim/2.f;
              v3 p    = (EditRelxyz - Center);
              v4 w    = DoInputTransforms(p, RotMatrix, Stretch, Repeat);
              f32 IQSample = w.w+iq_sdBox(w.xyz, BoxR);
              if (Hollow > 0.f) { IQSample = iq_opOnion(IQSample, Hollow ); }
              InitialSample = -IQSample;

            } break;

            // ShapeType_Sphere
            case 1:
            {
              f32 Rad = Radius;
              if (Rad <= 0.f) { Rad = min(min(EditRad.x, EditRad.y), EditRad.z); }
              Rad -= Hollow;

              v3 p  = (EditRelxyz - EditRelativeSphereCenter);
              v4 w = DoInputTransforms(p, RotMatrix, Stretch, Repeat);
              f32 IQSample  = w.w+iq_sdSphere(w.xyz, Rad);
              if (Hollow > 0.f) { IQSample = iq_opOnion(IQSample, Hollow ); }
              InitialSample = -IQSample;
            } break;

            // ShapeType_Line
            case 2:
            {
              v3 p = EditRelxyz;
              v3 start = v3(Radius);
              v3 end = EditDim-v3(Radius);

              v4 w = DoInputTransforms(p, RotMatrix, Stretch, Repeat);
              f32 IQSample  = w.w+iq_sdRoundedLine(w.xyz, start, end, Radius);
              /* if (Hollow > 0.f) { IQSample = iq_opOnion(IQSample, Hollow ); } */
              InitialSample = -IQSample;
            } break;

            // ShapeType_Cylinder
            case 3:
            {
              v3 p = (EditRelxyz - EditRad);
              v3 c = Axis;

              v4 w = DoInputTransforms(p, RotMatrix, Stretch, Repeat);

              f32 IQSample = w.w+iq_sdCappedCylinder(w.xyz, Height, Radius);
              if (Hollow > 0.f) { IQSample = iq_opOnion(IQSample, Hollow ); }
              InitialSample = -IQSample;
            } break;

            // ShapeType_Plane
            case 4:
            {
              f32 Dist = DistanceToPlane(PlaneNormal, Planed, EditRelxyz);
              if (abs(Dist) < PlaneRadius*ChunkResolution.x)
              {
                InitialSample = 1.f;
              }
            } break;

            // ShapeType_Torus
            case 5:
            {
              v2  t = v2(Radius, MinorRadius);
              v3  p = EditRelxyz;

              v3  BoxR = EditDim/2.f;
              p = EditRelxyz;
              p   -= BoxR;

              v4 w = DoInputTransforms(p, RotMatrix, Stretch, Repeat);

              f32 IQSample = w.w+iq_sdTorus( w.xyz, t );
              if (Hollow > 0.f) { IQSample = iq_opOnion(IQSample, Hollow ); }

              InitialSample = -IQSample;

            } break;

            // ShapeType_Pyramid
            case 6:
            {
              f32 S = EditDim.z;

              f32  h = Radius > 0.f ? Radius : 1.f;

              v3  BoxR = EditDim/(2.f*S);
              v3  p = EditRelxyz/EditDim;
              p.xy   -= 0.5f;

              v4 w = DoInputTransforms(p, RotMatrix, Stretch, Repeat);

              f32 IQSample = w.w+iq_sdPyramid( w.xyz, h );
              if (Hollow > 0.f) { IQSample = iq_opOnion(IQSample, Hollow ); }

              InitialSample = -IQSample;
            } break;

            // @sdf_shape_step(7): Add more cases and implementations here
            // for shape types added in Step 1
            //
          }

          InitialSample += Rounding;
        } break;

        default: {ColorValue = V3(1.f, 0.f, 1.f);  Accumulator = 1.f;} break;
      }

      /* InitialSample = Clamp01(InitialSample); */

      f32 ThisSample = (InitialSample + ValueBias);
      if (Invert)
      {
        ThisSample = ThisSample * -1.f;
      }









      if ( (ValueModifiers & (1<<1)) > 0) // WorldEdit_ValueModifier_ClampPos
      {
        ThisSample = max(0.f, ThisSample);
      }

      if ( (ValueModifiers & (1<<2)) > 0) // WorldEdit_ValueModifier_ClampNeg
      {
        ThisSample = min(0.f, ThisSample);
      }

      if ( (ValueModifiers & (1<<3)) > 0) // WorldEdit_ValueModifier_Threshold
      {
        if (abs(InitialSample) < Threshold) { ThisSample = 0.f; }
      }

      if ( (ValueModifiers & (1<<4)) > 0) // WorldEdit_ValueModifier_Discard
      {
        ThisSample = 0.f;
      }




      BlendSample(BlendMode, Accumulator, ColorValue, ThisSample, ColorSample);




    }


  }

  // We sample the blend texture outside the bounds check because we need to pass
  // the previous stage sample values through
  if (SampleBlendTex > 0)
  {
    v4 TexLookup = texelFetch(BlendTex, ivec2(gl_FragCoord.xy), 0);

    f32 BlendValue = TexLookup.a;
    /* f32 BlendValue = -1.f*TexLookup.a; */
    v3 BlendColor = TexLookup.rgb;


#if 1
    /* f32 A = -1.f*Accumulator; */
    f32 A = Accumulator;
    BlendSample(BlendTexBlendMode, BlendValue, BlendColor, A, ColorValue);

    Accumulator = BlendValue;
    ColorValue = BlendColor;
#else
    BlendSample(BlendTexBlendMode, Accumulator, ColorValue, BlendValue, BlendColor);
#endif

    /* if (Accumulator <= 0.f) */
    /* /1* if (TexLookup.a > 0.f) *1/ */
    /* { */
    /*   // Take Max of Accumulator or current world value */
    /*   if (Accumulator < TexLookup.a) */
    /*   { */
    /*     Accumulator = TexLookup.a; */
    /*     ColorValue  = TexLookup.rgb; */
    /*   } */
    /* } */
  }




  Output.a = Accumulator;
  Output.rgb = ColorValue;
}
