uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

uniform int BrushType;
uniform int BlendMode;
uniform int ColorMode;
uniform int Modifiers;

//
// Clipping params
//
uniform v3 ChunkRelEditMin;
uniform v3 ChunkRelEditMax;

//
// Noise params
//
uniform v3 RGBColor;
uniform v3 Period;
uniform f32 Amplitude;



uniform sampler2D InputTex;

in vec2 UV;
out layout(location = 0) vec4 Output;

void main()
{
  v4 TexLookup = texelFetch(InputTex, ivec2(gl_FragCoord.xy), 0);

  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = TexLookup.rgb;
  f32 NoiseValue = TexLookup.a;


  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  v3 xyz = V3(x,y,z) * ChunkResolution;

  if (
      xyz.x >= ChunkRelEditMin.x &&
      xyz.y >= ChunkRelEditMin.y &&
      xyz.z >= ChunkRelEditMin.z &&

      xyz.x <= ChunkRelEditMax.x &&
      xyz.y <= ChunkRelEditMax.y &&
      xyz.z <= ChunkRelEditMax.z  )
  {
    v3 Offset = V3(-1, -1, -1);
    v3 Basis = Offset + WorldspaceBasis + xyz;


    {
      f32 NoiseSample = 0.f;
      switch (BrushType)
      {
        case 4: // WorldEdit_BrushType_Layered
        {
          s32 Octaves = 1;

          v3 deriv = v3(0.f);
          f32 warp = 0.f;

          for (s32 Octave = 1; Octave <= Octaves; ++Octave)
          {
            v3 xyz = Basis / (Period/Octave);
            NoiseSample = value_noise_derivs(xyz+warp+10.f).x * (Amplitude/Octave);
          }

          break;
        }

        default: {ColorValue = V3(1.f, 0.f, 0.f); NoiseValue = 1.f;} break;
      }

  /* WorldEdit_ValueModifier_Surface  = (1<<0), */
  /* WorldEdit_ValueModifier_ClampPos = (1<<1), */
  /* WorldEdit_ValueModifier_ClampNeg = (1<<2), */
  /* WorldEdit_ColorModifier_ColorDiscard = (1<<3), */

      if ( (Modifiers & (1<<0)) > 0) // WorldEdit_ValueModifier_Surface
      {
        // TODO(Jesse): Check if it's a surface voxel here
      }

      if ( (Modifiers & (1<<1)) > 0) // WorldEdit_ValueModifier_ClampPos
      {
        NoiseSample = max(0.f, NoiseSample);
      }

      if ( (Modifiers & (1<<2)) > 0) // WorldEdit_ValueModifier_ClampNeg
      {
        NoiseSample = min(0.f, NoiseSample);
      }


      switch (BlendMode)
      {
        case 0: // Addative
        { NoiseValue = NoiseValue + NoiseSample; } break;

        case 1: // Subtractive
        { NoiseValue = NoiseValue - NoiseSample; } break;
      }

      switch (ColorMode)
      {
        case 0: // Addative
        { if (NoiseSample > 0.f) { ColorValue = ColorValue + RGBColor; } } break;

        case 1: // Subtractive
        { if (NoiseSample < 0.f) { ColorValue = ColorValue - RGBColor; } } break;
      }

    }

  }

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
