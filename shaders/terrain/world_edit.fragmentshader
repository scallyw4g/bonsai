uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

uniform int BrushType;
uniform int BlendMode;
uniform int ColorMode;
uniform int Modifiers;


//
// Clipping params
//
uniform v3 ChunkRelEditMin;
uniform v3 ChunkRelEditMax;


//
// Shape params
//
uniform int ShapeType;


//
// Noise params
//
uniform int NoiseType;
uniform v3 RGBColor;
uniform v3 Period;
uniform f32 Amplitude;
uniform f32 Threshold;
uniform bool Invert;

//
// Voronoi Params
//
uniform f32 Squareness; // 0 == not square, 1 == square



uniform sampler2D InputTex;

in vec2 UV;
out layout(location = 0) vec4 Output;




// https://thebookofshaders.com/10/
float rand(vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

float hash(float x)  { return fract(x + 1.32154 * 1.2151); }
vec3 RandomV3FromFloat(float x) { return vec3(hash(((x   + 0.5283) * 59.3829) * 274.3487), hash(((x   + 0.8192) * 83.6621) * 345.3871), hash(((x   + 0.2157f) * 36.6521f) * 458.3971f)); }
vec3 RandomV3FromV3(v3 V)       { return vec3(rand(V.xy), rand(V.yz), rand(V.xz)); }


#define Floor floor
#define Abs abs
#define Clamp01(x) clamp(x, 0.f, 1.f)
#define LengthSq(V) (V.x*V.x + V.y*V.y + V.z*V.z)
#define Normalize normalize
#define Dot dot
#define Min min

#define True true
#define False false
#define b32 bool

link_internal f32
voronoi(v3 Texel)
{
  v3 baseCell = Floor(Texel);

  v3 CellOffsets[27];

  // first pass to find the closest cell
  //
  f32 minDistToCellSq = 100;
  v3 toClosestCell;
  v3 closestCell;
  s32 CellIndex = 0;
  for( s32 x1 = -1;
           x1 <= 1;
         ++x1 )
  {
    for(s32 y1 = -1;
            y1 <= 1;
          ++y1 )
    {
      for( s32 z1 = -1;
               z1 <= 1;
             ++z1 )
      {
        v3 cell      =  baseCell + V3(x1, y1, z1);
        v3 offset    = Clamp01(RandomV3FromV3(cell) - Squareness);
        v3 cellPosition = cell + offset;

        v3 toCell = cellPosition - Texel;
        f32 distToCellSq = LengthSq(toCell);
        if(distToCellSq < minDistToCellSq)
        {
          minDistToCellSq = distToCellSq;
          closestCell = cell;
          toClosestCell = toCell;
        }

        CellOffsets[CellIndex++] = offset;
      }
    }
  }
  //
  // TODO(Jesse): This seems like you'd just want to do it in-line in the first
  // loop ..?
  //
  // second pass to find the distance to the closest edge
  //
  f32 minEdgeDistance = 10;
  CellIndex = 0;
  for( s32 x2 = -1;
           x2 <= 1;
         ++x2 )
  {
    for(s32 y2 = -1;
            y2 <= 1;
          ++y2 )
    {
      for( s32 z2 = -1;
               z2 <= 1;
             ++z2 )
      {
        /* v3 cell = (baseCell + V3(x2, y2, z2)); */
        v3 cell = baseCell + V3(x2, y2, z2);
        v3 offset = CellOffsets[CellIndex++];

        v3 cellPosition = cell + offset;
        v3 toCell = cellPosition - Texel;

        v3 diffToClosestCell = Abs(closestCell - cell);
        b32 isClosestCell = diffToClosestCell.x + diffToClosestCell.y + diffToClosestCell.z < 0.1f;
        if(isClosestCell == False)
        {
          v3 toCenter = (toClosestCell + toCell) * 0.5;
          v3 cellDifference = Normalize(toCell - toClosestCell);
          f32 edgeDistance = Dot(toCenter, cellDifference);
          minEdgeDistance = Min(minEdgeDistance, edgeDistance);
        }
      }
    }
  }
  return minEdgeDistance;
  /* return sqrt(minDistToCellSq); */
  /* return closestCell; */
}


void main()
{
  v4 TexLookup = texelFetch(InputTex, ivec2(gl_FragCoord.xy), 0);

  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = TexLookup.rgb;
  f32 NoiseValue = TexLookup.a;


  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  v3 xyz = V3(x,y,z) * ChunkResolution;

  // TODO(Jesse): I have no idea why this works out to > Min and <= Max.  I
  // think it should be >= Min and < Max .. but I'm just going to leave it for now..
  if (
      xyz.x > ChunkRelEditMin.x &&
      xyz.y > ChunkRelEditMin.y &&
      xyz.z > ChunkRelEditMin.z &&

      xyz.x <= ChunkRelEditMax.x &&
      xyz.y <= ChunkRelEditMax.y &&
      xyz.z <= ChunkRelEditMax.z  )
  {
    v3 Basis = WorldspaceBasis + xyz;


    {
      v3 ColorSample = RGBColor;
      f32 NoiseSample = 0.f;

      s32 Octaves = 1;
      switch (BrushType)
      {
        case 0: // BrushLayerType_Noise
        {
          v3 NoiseBasis = Basis / Period;
          switch (NoiseType)
          {
            case 0: // NoiseType_Perlin:
            {
              NoiseSample = value_noise_derivs(NoiseBasis).x;
            } break;

            case 1: // NoiseType_Voronoi:
            {
              NoiseSample = voronoi(NoiseBasis);
            } break;

            case 2: // NoiseType_White:
            {
            } break;
          }

          break;
        }

        case 1: // BrushLayerType_Shape
        {
          switch (ShapeType)
          {
            // ShapeType_Sphere
            case 0: { } break; 

            // ShapeType_Rect
            case 1: { NoiseSample = 1.f; } break;

            // ShapeType_Cylinder
            case 2: { } break;
          }
        } break;

        default: {ColorValue = V3(1.f, 0.f, 0.f); NoiseValue = 1.f;} break;
      }

      // TODO(Jesse): This is buggy; it generates extra geometry on the edges
      // of chunks for some reason.  At the moment it's a non-issue because the
      // additional geometry is always below the ground, and doesn't cause
      // visible artifacts.  At the moment I just want anything 'working', but
      // this should definitely be improved in the future.
      //
      if ( (Modifiers & (1<<0)) > 0) // WorldEdit_ValueModifier_Surface
      {
        if (x > 0 && x < 65 &&
            y > 0 && y < 65 &&
            z > 0 && z < 65)
        {
          f32 ThisCell = sign(TexLookup.a);
          if (ThisCell < 0.f)
          {
            // only consider cells that are air
            s32 IsSurface  = s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(1, 0), 0).a));
                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(1, 0), 0).a));

                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 1), 0).a));
                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 1), 0).a));

                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 66), 0).a));
                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 66), 0).a));

            if (IsSurface == 0) { NoiseSample = 0.f; ColorSample = V3(0,0,0); }
          }
          else
          {
            NoiseSample = 0.f; ColorSample = V3(0,0,0);
          }
        }
        else
        {
          NoiseSample = 0.f; ColorSample = V3(0,0,0);
        }
      }

      if ( (Modifiers & (1<<1)) > 0) // WorldEdit_ValueModifier_ClampPos
      {
        NoiseSample = max(0.f, NoiseSample);
      }

      if ( (Modifiers & (1<<2)) > 0) // WorldEdit_ValueModifier_ClampNeg
      {
        NoiseSample = min(0.f, NoiseSample);
      }

      if (abs(NoiseSample) < Threshold)
      {
        NoiseSample = 0.f;
      }

      if (Invert)
      {
        NoiseSample *= -1.f;
      }

      f32 Amp = max(Amplitude, 1.f);
      NoiseSample *= Amp;
      /* NoiseSample *= Amplitude; */

      switch (BlendMode)
      {
        case 0: // Addative
        { NoiseValue = NoiseValue + NoiseSample; } break;

        case 1: // Subtractive
        { NoiseValue = NoiseValue - NoiseSample; } break;

        case 2: // Threshold
        { if (NoiseSample > Threshold) NoiseValue = NoiseSample; } break;
      }


      switch (ColorMode)
      {
        case 0: // ThresholdPositive
        { if (NoiseSample > 0.f) { ColorValue = ColorSample; } } break;

        case 1: // ThresholdNegative
        { if (NoiseSample < 0.f) { ColorValue = ColorSample; } } break;

        case 2: // Addative
        { ColorValue = ColorValue + ColorSample; } break;

        case 3: // Subtractive
        { ColorValue = ColorValue - ColorSample; } break;

        case 4: // Multiply
        { ColorValue = ColorValue - ColorSample; } break;

        case 5: // Divide
        { ColorValue = ColorValue - ColorSample; } break;

        case 6: // Average
        { f32 StartingIntensity = length(ColorValue);
          ColorValue = (ColorValue + ColorSample)/StartingIntensity; } break;
      }

    }

  }

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
