uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

uniform int BrushType;
uniform int BlendMode;
uniform int ColorMode;
uniform int Modifiers;

//
// Clipping params
//
uniform v3 ChunkRelEditMin;
uniform v3 ChunkRelEditMax;

//
// Noise params
//
uniform v3 RGBColor;
uniform v3 Period;
uniform f32 Amplitude;



uniform sampler2D InputTex;

in vec2 UV;
out layout(location = 0) vec4 Output;

void main()
{
  v4 TexLookup = texelFetch(InputTex, ivec2(gl_FragCoord.xy), 0);

  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = TexLookup.rgb;
  f32 NoiseValue = TexLookup.a;


  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  v3 xyz = V3(x,y,z) * ChunkResolution;

  if (
      xyz.x >= ChunkRelEditMin.x &&
      xyz.y >= ChunkRelEditMin.y &&
      xyz.z >= ChunkRelEditMin.z &&

      xyz.x <= ChunkRelEditMax.x &&
      xyz.y <= ChunkRelEditMax.y &&
      xyz.z <= ChunkRelEditMax.z  )
  {
    v3 Offset = V3(-1, -1, -1);
    v3 Basis = Offset + WorldspaceBasis + xyz;


    {
      v3 ColorSample = RGBColor;
      f32 NoiseSample = 0.f;
      /* switch (BrushType) */
      {
        /* case 4: // WorldEdit_BrushType_Layered */
        {
          s32 Octaves = 1;

          v3 deriv = v3(0.f);
          f32 warp = 0.f;

          for (s32 Octave = 1; Octave <= Octaves; ++Octave)
          {
            v3 xyz = Basis / (Period/Octave);
            NoiseSample = value_noise_derivs(xyz+warp+10.f).x * (Amplitude/Octave);
          }

          /* break; */
        }

        /* default: {ColorValue = V3(1.f, 0.f, 0.f); NoiseValue = 1.f;} break; */
      }

      // TODO(Jesse): This is buggy; it generates extra geometry on the edges
      // of chunks for some reason.  At the moment it's a non-issue because the
      // additional geometry is always below the ground, and doesn't cause
      // visible artifacts.  At the moment I just want anything 'working', but
      // this should definitely be improved in the future.
      //
      if ( (Modifiers & (1<<0)) > 0) // WorldEdit_ValueModifier_Surface
      {
        if (x > 0 && x < 65 &&
            y > 0 && y < 65 &&
            z > 0 && z < 65)
        {
          f32 ThisCell = sign(TexLookup.a);
          if (ThisCell < 0.f)
          {
            // only consider cells that are air
            s32 IsSurface  = s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(1, 0), 0).a));
                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(1, 0), 0).a));

                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 1), 0).a));
                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 1), 0).a));

                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 66), 0).a));
                IsSurface |= s32(ThisCell < sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 66), 0).a));

            if (IsSurface == 0) { NoiseSample = 0.f; ColorSample = V3(0,0,0); }
          }
          else
          {
            NoiseSample = 0.f; ColorSample = V3(0,0,0);
          }
        }
        else
        {
          NoiseSample = 0.f; ColorSample = V3(0,0,0);
        }
      }

      if ( (Modifiers & (1<<1)) > 0) // WorldEdit_ValueModifier_ClampPos
      {
        NoiseSample = max(0.f, NoiseSample);
      }

      if ( (Modifiers & (1<<2)) > 0) // WorldEdit_ValueModifier_ClampNeg
      {
        NoiseSample = min(0.f, NoiseSample);
      }


      switch (BlendMode)
      {
        case 0: // Addative
        { NoiseValue = NoiseValue + NoiseSample; } break;

        case 1: // Subtractive
        { NoiseValue = NoiseValue - NoiseSample; } break;
      }


      switch (ColorMode)
      {
        case 0: // ThresholdPositive
        { if (NoiseSample > 0.f) { ColorValue = ColorSample; } } break;

        case 1: // ThresholdNegative
        { if (NoiseSample < 0.f) { ColorValue = ColorSample; } } break;

        case 2: // Addative
        { ColorValue = ColorValue + ColorSample; } break;

        case 3: // Subtractive
        { ColorValue = ColorValue - ColorSample; } break;

        case 4: // Multiply
        { ColorValue = ColorValue - ColorSample; } break;

        case 5: // Divide
        { ColorValue = ColorValue - ColorSample; } break;

        case 6: // Average
        { f32 StartingIntensity = length(ColorValue);
          ColorValue = (ColorValue + ColorSample)/StartingIntensity; } break;
      }

    }

  }

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
