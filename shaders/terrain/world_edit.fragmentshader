uniform  v3 WorldspaceChunkBasis;
uniform  v3 ChunkResolution;

uniform int BrushType;
uniform int BlendMode;
uniform int ColorMode;
uniform int Modifiers;

uniform int GenerateNormals;

uniform f32 Power;

//
// Clipping params
//
uniform v3 ChunkRelEditMin;
uniform v3 ChunkRelEditMax;


//
// Shape params
//
uniform s32 ShapeType; // shape_type

//
// Sphere Params
//
uniform  v3 ChunkRelLocation;
uniform f32 Radius;

//
// Cylinder Params
//

uniform s32 Axis; // voxel_rule_direction

//
// Plane Params
//
uniform v3 PlaneNormal;
uniform f32 Planed;
uniform f32 PlaneRadius;




//
// Noise params
//
uniform  int NoiseType;
uniform   v3 RGBColor;
uniform   v3 Period;
uniform  f32 Threshold;
uniform bool Invert;

//
// Voronoi Params
//
uniform f32 Squareness; // 0 == not square, 1 == square



uniform sampler2D InputTex;

in vec2 UV;
out vec4 Output;

r32 DistanceToPlane(v3 PlaneNormal, f32 Planed, v3 P)
{
  r32 a = PlaneNormal.x;
  r32 b = PlaneNormal.y;
  r32 c = PlaneNormal.z;

  r32 d = Planed;

  r32 Distance = a*P.x + b*P.y + c*P.z + d;
  return Distance;
}

void main()
{
  v4 TexLookup = texelFetch(InputTex, ivec2(gl_FragCoord.xy), 0);

  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = TexLookup.rgb;
  f32 NoiseValue = TexLookup.a;

  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));
  v3 xyz = V3(x,y,z) * ChunkResolution;


  // TODO(Jesse): I have no idea why this works out to > Min and <= Max.  I
  // think it should be >= Min and < Max .. but I'm just going to leave it for now..
  if (
      xyz.x > ChunkRelEditMin.x &&
      xyz.y > ChunkRelEditMin.y &&
      xyz.z > ChunkRelEditMin.z &&

      xyz.x <= ChunkRelEditMax.x &&
      xyz.y <= ChunkRelEditMax.y &&
      xyz.z <= ChunkRelEditMax.z  )
  {
    v3 Basis = WorldspaceChunkBasis + xyz;
    v3 EditRelPosition = xyz - ChunkRelEditMin;


    {
      v3 ColorSample = RGBColor;
      f32 NoiseSample = 0.f;

      s32 Octaves = 1;
      switch (BrushType)
      {
        case 0: // BrushLayerType_Noise
        {
          v3 NoiseBasis = Basis / Period;
          switch (NoiseType)
          {
            case 0: // NoiseType_Perlin:
            {
              NoiseSample = value_noise_derivs(NoiseBasis).x;
            } break;

            case 1: // NoiseType_Voronoi:
            {
              NoiseSample = voronoi_noise(NoiseBasis, Squareness).x;
            } break;

            case 2: // NoiseType_White:
            {
            } break;
          }

          break;
        }

        case 1: // BrushLayerType_Shape
        {
          switch (ShapeType)
          {
            // ShapeType_Rect
            case 0: { NoiseSample = 1.f; } break;

            // ShapeType_Sphere
            case 1:
            {
              f32 Dist = 0.5f+distance(ChunkRelLocation, xyz);
              if (Dist < Radius) { NoiseSample = ((Radius-Dist)/Radius)*Power; }
            } break;

            // ShapeType_Line
            case 2:
            {
              // TODO(Jesse): Mr. Jippity said this is how to do distance to
              // line and it works, although I'm not sure it's necessarily a very good way to do it ..
              v3 Line = normalize(ChunkRelEditMax-ChunkRelEditMin);
              v3 X = cross(Line, EditRelPosition);
              f32 Dist = length(X)/length(Line);
              /* if (Dist < Radius) { NoiseSample = ((Radius-Dist)/Radius)*Power; } */
              /* if (Dist < Radius) { NoiseSample = Dist*Power; } */
              if (Dist < Radius) { NoiseSample = Power; }
            } break;

            // ShapeType_Cylinder
            case 3:
            {
              v3 AxisMask;
              v3 InvAxisMask;
              v3 EditDim = ChunkRelEditMax-ChunkRelEditMin;

              switch (Axis)
              {
                case 0: // VoxelRuleDir_PosX
                case 1: // VoxelRuleDir_NegX
                {
                  AxisMask    = V3(1,0,0);
                  InvAxisMask = V3(0.f,1.f,1.f)*0.5f;
                } break;

                case 2: // VoxelRuleDir_PosY
                case 3: // VoxelRuleDir_NegY
                {
                  AxisMask    = V3(0,1,0);
                  InvAxisMask = V3(1.f,0.f,1.f)*0.5f;
                } break;

                case 4: // VoxelRuleDir_PosZ
                case 5: // VoxelRuleDir_NegZ
                {
                  AxisMask    = V3(0,0,1);
                  InvAxisMask = V3(1.f,1.f,0.f)*0.5f;
                } break;

              }

              v3 MajorAxis  = EditDim*AxisMask;
              v3 MinorAxies = EditDim*InvAxisMask;

              v3 ChunkRelP0 = MinorAxies;
              v3 ChunkRelP1 = MinorAxies + MajorAxis;

              v3 Line = ChunkRelP1 - ChunkRelP0;
              v3 LineRelativeXYZ = EditRelPosition - ChunkRelP0;

              v3 X = cross(Line, LineRelativeXYZ);
              f32 Dist = length(X)/length(Line);
              if (Dist < Radius) { NoiseSample = Power; }
            } break;

            // ShapeType_Plane
            case 4:
            {
              f32 Dist = DistanceToPlane(PlaneNormal, Planed, xyz);
              if (abs(Dist) < PlaneRadius)
              {
                NoiseSample = 1.f;
              }
            } break;

            // @sdf_shape_step(7): Add more cases and implementations here
            // for shape types added in Step 1
            //
          }
        } break;

        default: {ColorValue = V3(1.f, 0.f, 0.f); NoiseValue = 1.f;} break;
      }

      // TODO(Jesse): This is buggy; it generates extra geometry on the edges
      // of chunks for some reason.  At the moment it's a non-issue because the
      // additional geometry is always below the ground, and doesn't cause
      // visible artifacts.  At the moment I just want anything 'working', but
      // this should definitely be improved in the future.
      //
      if ( (Modifiers & (1<<0)) > 0) // WorldEdit_ValueModifier_Surface
      {
        if (x > 0 && x < 65 &&
            y > 0 && y < 65 &&
            z > 0 && z < 65)
        {
          f32 ThisCell = sign(TexLookup.a);
          if (ThisCell < 0.f) // Current value is Air
          {
            s32 IsSurface  = s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(1, 0), 0).a ) > 0.f);
                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(1, 0), 0).a ) > 0.f);

                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 1), 0).a ) > 0.f);
                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 1), 0).a ) > 0.f);

                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 66), 0).a) > 0.f);
                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 66), 0).a) > 0.f);

            if (IsSurface == 0) { NoiseSample = 0.f; ColorSample = V3(0,0,0); }
          }
          else // Current NoiseValue is Solid
          {
            s32 IsSurface  = s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(1, 0), 0).a ) < 0.f);
                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(1, 0), 0).a ) < 0.f);

                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 1), 0).a ) < 0.f);
                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 1), 0).a ) < 0.f);

                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) + ivec2(0, 66), 0).a) < 0.f);
                IsSurface |= s32(sign(texelFetch(InputTex, ivec2(gl_FragCoord.xy) - ivec2(0, 66), 0).a) < 0.f);

            if (IsSurface == 0) { NoiseSample = 0.f; ColorSample = V3(0,0,0); }
          }
        }
        else
        {
          NoiseSample = 0.f; ColorSample = V3(0,0,0);
        }
      }

      if ( (Modifiers & (1<<1)) > 0) // WorldEdit_ValueModifier_ClampPos
      {
        NoiseSample = max(0.f, NoiseSample);
      }

      if ( (Modifiers & (1<<2)) > 0) // WorldEdit_ValueModifier_ClampNeg
      {
        NoiseSample = min(0.f, NoiseSample);
      }

      if ( (Modifiers & (1<<3)) > 0) // WorldEdit_ValueModifier_Threshold
      {
        if (NoiseSample > Threshold) NoiseValue = NoiseSample;
      }



      if (abs(NoiseSample) < Threshold)
      {
        NoiseSample = 0.f;
      }



      if (Invert)
      {
        NoiseSample *= -1.f;
      }

      NoiseSample *= max(Power, 1.f);

      switch (BlendMode)
      {
        case 0: // Addative
        { NoiseValue = NoiseValue + NoiseSample; } break;

        case 1: // Subtractive
        { NoiseValue = NoiseValue - NoiseSample; } break;
      }


      switch (ColorMode)
      {
        case 0: // ThresholdPositive
        { if (NoiseSample > 0.f) { ColorValue = ColorSample; } } break;

        case 1: // ThresholdNegative
        { if (NoiseSample < 0.f) { ColorValue = ColorSample; } } break;

        case 2: // Addative
        { ColorValue = ColorValue + ColorSample; } break;

        case 3: // Subtractive
        { ColorValue = ColorValue - ColorSample; } break;

        case 4: // Multiply
        { ColorValue = ColorValue * ColorSample; } break;

        case 5: // Divide
        { ColorValue = SafeDivide0(ColorValue, ColorSample); } break;

        case 6: // Average
        { f32 StartingIntensity = length(ColorValue);
          ColorValue = (ColorValue + ColorSample)/StartingIntensity; } break;
      }

    }

  }

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
