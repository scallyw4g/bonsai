uniform  v2 SampleRemapCurvePoints[16];
uniform u32 SampleRemapCurvePointCount;

uniform v3 WorldspaceChunkBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;









uvec3 murmurHash33(uvec3 src) {
    const uint M = 0x5bd1e995u;
    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);
    src *= M; src ^= src>>24u; src *= M;
    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;
    h ^= h>>13u; h *= M; h ^= h>>15u;
    return h;
}

// 3 outputs, 3 inputs
vec3 hash(vec3 src) {
    uvec3 h = murmurHash33(floatBitsToUint(src));
    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;
}

float sdBox( in vec2 p, in vec2 b, in vec4 r )
{
    r.xy = (p.x>0.0)?r.xy : r.zw;
    r.x  = (p.y>0.0)?r.x  : r.y;
    vec2 q = abs(p)-b+r.x;
    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
}

float sdPentagram(in vec2 p, in float r )
{
  float k1x = 0.809016994f;
  float k2x = 0.309016994f;
  float k1y = 0.587785252f;
  float k2y = 0.951056516f;
  float k1z = 0.726542528f;
  vec2 ve1  = vec2( k1x,-k1y);
  vec2 ve2  = vec2(-k1x,-k1y);
  vec2 ve3  = vec2( k2x,-k2y);

  p.x = abs(p.x);
  p -= 2.0*max(dot(ve1,p),0.0)*ve1;
  p -= 2.0*max(dot(ve2,p),0.0)*ve2;
  p.x = abs(p.x);
  p.y -= r;
  return length(p-ve3*clamp(dot(p,ve3),0.0,k1z*r))
         * sign(p.y*ve3.x-p.x*ve3.y);
}

// returns offset to the center of the cell in the current tile
vec2 get_point(vec2 pos){
    ivec2 p = ivec2(floor(pos - 1.)) * 3;
    vec3 rng = hash(vec3(float(p.x), float(p.y), float(p.x + p.y)));
    return rng.xy;
}

const vec2 offsets[24] = vec2[24](
    vec2(-2, -2),
    vec2(-1, -2),
    vec2(0, -2),
    vec2(1, -2),
    vec2(2, -2),
    vec2(-2, -1),
    vec2(-1, -1),
    vec2(0, -1),
    vec2(1, -1),
    vec2(2, -1),
    vec2(-2, 0),
    vec2(-1, 0),
    vec2(1, 0),
    vec2(2, 0),
    vec2(-2, 1),
    vec2(-1, 1),
    vec2(0, 1),
    vec2(1, 1),
    vec2(2, 1),
    vec2(-2, 2),
    vec2(-1, 2),
    vec2(0, 2),
    vec2(1, 2),
    vec2(2, 2)

);

float sdShape(vec2 pos){
    //return sdBox(pos, vec2(.8), vec4(0.));
    return sdPentagram(pos, .9);
}

float sdVoronoi(vec2 pos){
    pos-=.5;
    vec2 p = fract(pos);

    //nearest is initialized to the center cell because of potential future optimizations to reduce iteration count
    vec2 nearest = get_point(pos);
    vec2 lastnearest = vec2(100.);
    vec2 current = vec2(0.);

    vec3 dists = vec3(
        sdShape(p-nearest),
        sdShape(p-lastnearest),
        sdShape(p-current));

    //finding the two nearest points to the sampling point
    for (int i = 0; i<24; i++){
        current = offsets[i];
        current += get_point(pos+offsets[i]);
        dists.z = sdShape(p-current);
        if (dists.z<dists.y){
            dists.yz = dists.zy;
            lastnearest = current;
        }
        if (dists.y<dists.x){
            dists.xy = dists.yx;
            lastnearest = nearest;
            nearest = current;
        }
    }

    //float d = length(p-lastnearest)-.5+.5*(cos(iTime));
    float d = sdShape(p-lastnearest);
    return d;
}

float scene(vec2 p){
    float d = sdVoronoi(p);

    return d;
}

vec4 noise( vec2 uv )
{
  vec2 m = vec2(0,0);
  float d = scene(uv);

  vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);
  col *= 2.0 - exp(-6.0*abs(d));
  col *= 0.8 + 0.2*cos(150.0*d);
  col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)));

  if(uv.x<0.)col = vec3(smoothstep(-1., 1., d));

  if (d<0.01 && d>0.){col = vec3(0.);}

  v4 Result = vec4(col,d);
  return Result;
}




void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 68);
  f32 y = floor(gl_FragCoord.y - (z*68));


  vec3 Offset = vec3(0);
  vec3 Basis = Offset + WorldspaceChunkBasis + (vec3(x,y,z)*ChunkResolution);


  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = vec3(0.f);
  f32 NoiseValue = 0.f;

  //
  // -- user code --
  //
  {
    f32 StartingZDepth = DEFAULT_FLOOR_HEIGHT;
    NoiseValue += StartingZDepth - Basis.z;

    f32 CliffMask = 1.f;
    {
      vec3 Period = vec3(250.f);
      /* vec3 Period = vec3(10.f); */
      float Amplitude = 800.f;

      vec3 xyz = Basis / Period;
      v4 N = noise(xyz.xy);
      N.w *= -1.f;
      N.w = ClampPositive(N.w);

      N.w = (N.w/2.f)+0.5f;

      N.w = RemapSample(N.w, SampleRemapCurvePoints, SampleRemapCurvePointCount );

      NoiseValue += ClampPositive(N.w * Amplitude);
      ColorValue = N.rgb;
    }

  }

  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
