uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out uint Output;

float sstep(float init_x){
    float x = clamp(init_x,-1.,1.);
    x = abs(x);
    return sign(init_x)*(x*(2.-x));
}
#define PI 3.14159265359
#define PI_INV 0.31830988618

float dot2( in vec2 v ) { return dot(v,v); }

//trapezoid SDF from IQ
float sdTrapezoid( in vec2 p, in float r1, float r2, float he ){
    p = vec2(p.y, -p.x);
    vec2 k1 = vec2(r2,he);
    vec2 k2 = vec2(r2-r1,2.0*he);
    p.x = abs(p.x);
    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);
    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );
    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) );
}

float brick_size(float id, float n, float r){
    return (cos(mod(round(id)+.4, 2.)*PI)*.5+.5)*.5*r;
}

float sdBrickCircle(vec2 p, float r, float n, float padding, float rotation){

    float inv_n = 1./n;
    rotation *= n;
    
    vec2 point = normalize(p);
    float angle = atan(point.y, point.x); // angle from the x axis
    float neighbor = 0.;
    
    //quantization of the normal's angle. you must normalize the angle before doing quantization
    angle *= n*PI_INV;
    
    angle += rotation;
    
    angle = floor(angle);
    
    vec2 ids = vec2(angle);
    
    angle -= rotation;
    
    ids.y += 1.;
    
    neighbor = angle + 1.;
    
    angle *= inv_n;
    angle *= PI;
    neighbor *=PI*inv_n;
    
    //recunstructing the normals
    vec2 right = vec2(cos(angle), sin(angle));
    vec2 left = vec2(cos(neighbor), sin(neighbor));
    
    vec2 sizes = vec2(brick_size(ids.x, n, r), brick_size(ids.y, n, r));
    
    //note : you can make the brick size not depend on the radius by removing r here
    vec4 radii = vec4((1.-cos(inv_n*PI))/sin(inv_n*PI));
    radii *= r + vec4(sizes.x, -sizes.x, sizes.y, -sizes.y);
    radii-=padding;
    
    vec3 brick0 = vec3(sizes.x, radii.x, radii.y);
    vec3 brick1 = vec3(sizes.y, radii.z, radii.w);
    
    vec2 p_right = vec2(p.x*right.x + p.y*right.y, p.x*right.y - p.y*right.x);
    p_right.x-=r;
    
    float d = sdTrapezoid(p_right, brick0.y, brick0.z, brick0.x);
    
    vec2 p_left = vec2(p.x*left.x + p.y*left.y, p.x*left.y - p.y*left.x);
    p_left.x-=r;

    d = min(d, sdTrapezoid(p_left, brick1.y, brick1.z, brick1.x));
    
    return d;
}

void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  v3 Offset = V3(-1, -1, -1);
  v3 Basis = Offset + WorldspaceBasis + (v3(x,y,z)*ChunkResolution);
  Basis *= .2;

  // NOTE(Jesse): Set these in the -- user code -- section
  v3 ColorValue = V3(0.f);
  f32 NoiseValue = 0.f;

  //
  // -- user code -- 
  //
  {
    vec3 p = Basis;
    float size = 200;

    f32 d = sdBrickCircle(p.xz-size, size*.5, 10., 1., 0.);

    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);
    col *= 1.0 - exp(-9.0*abs(d));
    col *= 0.8 + 0.2*cos(1.0*d);
    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,1.,abs(d)));

    vec2 w = vec2( d, abs(p.y-80.) - 40. );
    d = min(max(w.x,w.y),0.0) + length(max(w,0.0));

    ColorValue = col;

    NoiseValue = d ;
  }

  //
  // -- end user code --
  //

  uint SolidBit = NoiseValue > 0.0f ? 1u : 0u;
  uint PackedColor = PackRGB(ColorValue);
  /* uint PackedColor = 3543u; */

  Output = (SolidBit << 15) | PackedColor;
}
