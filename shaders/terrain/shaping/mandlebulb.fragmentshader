uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out uint Output;

vec4 mandlebulb(vec3 p)
{
	p.xyz = p.xzy;
	vec3 z = p;
	vec3 dz=vec3(0.0);
	float power = 6.;
	float r, theta, phi;
	float dr = 1.2;
	
	float t0 = 1.0;
	for(int i = 0; i < 7; ++i) {
		r = length(z);
		if(r > 2.0) continue;
		theta = atan(z.y / z.x);
        #ifdef phase_shift_on
		phi = asin(z.z / r) + iTime*0.1;
        #else
        phi = asin(z.z / r);
        #endif
		
		dr = pow(r, power - 1.0) * dr * power + 1.0;
	
		r = pow(r, power);
		theta = theta * power;
		phi = phi * power;
		
		z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;
		
		t0 = min(t0, r);
	}

  f32 Thing = t0;
  Thing = pow(clamp(Thing, 0.0, 1.0), 0.55);
  vec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * Thing + vec3(0.0, 0.5, 1.0));

  vec4 Result = vec4(t0, tc0);
	return Result;
}


void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  v3 Offset = V3(-1, -1, -1);
  v3 Basis = Offset + WorldspaceBasis + (v3(x,y,z)*ChunkResolution);

  // NOTE(Jesse): Set these in the -- user code -- section
  v3 ColorValue = V3(0.f);
  f32 NoiseValue = 0.f;

  //
  // -- user code -- 
  //

  {
    v3 Period = V3(100.f);
    float Amplitude = 200.f;
    f32 StartingZDepth = 400.f;
    s32 Octaves = 1;

    NoiseValue = StartingZDepth;

    v3 xyz = Basis / (Period);
    v4 gn = mandlebulb((xyz/8.f)-1.4f)*v4(100.f, 1, 3, 18);
    ColorValue += abs(normalize(gn.yzw));

    NoiseValue = NoiseValue + (gn.x * (Amplitude));
    NoiseValue = NoiseValue - Basis.z;
  }

  //
  // -- end user code --
  //

  uint SolidBit = NoiseValue > 0.f ? 1u : 0u;
  uint PackedColor = PackRGB(ColorValue);

  Output = (SolidBit << 15) | PackedColor;
}
