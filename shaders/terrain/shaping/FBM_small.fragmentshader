uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;


void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  /* v3 Offset = V3(-1, -1, -1); */
  v3 Offset = V3(0);
  v3 Basis = Offset + WorldspaceBasis + (v3(x,y,z)*ChunkResolution);

  // NOTE(Jesse): Set these in the -- user code -- section
  v3 ColorValue = V3(0.f);
  f32 NoiseValue = 0.f;

  //
  // -- user code -- 
  //
  {

    v3 Period = V3(1500.f);
    float Amplitude = 150.f;
    f32 StartingZDepth = 1000;
    /* f32 StartingZDepth = 0; */
    s32 Octaves = 6;
    NoiseValue = StartingZDepth;

    f32 warp = 0.f;

    for (s32 Octave = 1; Octave <= Octaves; ++Octave)
    {
      v3 xyz = Basis / (Period/Octave);

      f32 gn = gradient_noise_derivs(xyz+warp).x;
      NoiseValue += gn*(Amplitude/Octave);
    }

    NoiseValue -= Basis.z;
    ColorValue = V3(0.2f, 0.8f, 0.15f);
    /* ColorValue = Basis/1000.f; */
    /* ColorValue = V3(x,y,z); */
    /* ColorValue = ChunkResolution/100.f; */
  }

  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;

  /* uint SolidBit = NoiseValue > 0.f ? 1u : 0u; */
  /* ColorValue = min(ColorValue, v3(1.f)); */
  /* uint PackedColor = PackRGB(ColorValue); */
  /* /1* uint PackedColor = 3543u; *1/ */

  /* Output = (SolidBit << 15) | PackedColor; */
}
