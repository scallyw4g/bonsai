uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;
/* layout (location = 0) out float Output; */


// https://www.shadertoy.com/view/4dffRH
//
//
//
// The MIT License
// Copyright © 2017 Inigo Quilez
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions: The above copyright
// notice and this permission notice shall be included in all copies or
// substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS",
// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// https://www.youtube.com/c/InigoQuilez
// https://iquilezles.org/

// Computes the analytic derivatives of a 3D Gradient Noise. This can be used for example to compute normals to a
// 3d rocks based on Gradient Noise without approximating the gradient by having to take central differences.
//
// More info here: https://iquilezles.org/articles/gradientnoise

// All noise functions here:
//
// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12


// 0: integer hash
// 1: float hash (aliasing based)
#define METHOD 1

// 0: cubic
// 1: quintic 
#define INTERPOLANT 1


#if METHOD==0
vec3 hash( ivec3 p )     // this hash is not production ready, please
{                        // replace this by something better
  ivec3 n = ivec3( p.x*127 + p.y*311 + p.z*74,
                   p.x*269 + p.y*183 + p.z*246,
                   p.x*113 + p.y*271 + p.z*124);

  // 1D hash by Hugo Elias
  n = (n << 13) ^ n;
  n = n * (n * n * 15731 + 789221) + 1376312589;
  return -1.0+2.0*vec3( n & ivec3(0x0fffffff))/float(0x0fffffff);
}

#else
vec3 hash( vec3 p )      // this hash is not production ready, please
{                        // replace this by something better
  p = vec3( dot(p,vec3(127.1,311.7, 74.7)),
            dot(p,vec3(269.5,183.3,246.1)),
            dot(p,vec3(113.5,271.9,124.6)));

  return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}
#endif

// Doesn't support integer hashing
#if METHOD == 1
float gradient_noise( in vec3 p )
{
    vec3 i = floor( p );
    vec3 f = fract( p );

    #if INTERPOLANT==1
    // quintic interpolant
    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);
    #else
    // cubic interpolant
    vec3 u = f*f*(3.0-2.0*f);
    #endif    

    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), 
                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),
                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), 
                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),
                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), 
                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),
                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), 
                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );
}
#endif

vec3 vhash(vec3 UV, vec3 offset)
{
	mat3 m = mat3(127.1,311.7, 74.7,269.5,183.3,246.1,113.5,271.9,124.6);
	UV = fract(sin(UV* m) * 46839.32);
	return vec3(sin(UV.z * +offset.x) * 0.5 + 0.5, cos(UV.x* offset.y) * 0.5 + 0.5,tan(UV.y * offset.z) * 0.5 + 0.5);
}

vec4 voronoi_noise(vec3 p, vec3 AngleOffset, vec3 CellDensity)
{
  vec3 g = floor(p * CellDensity);
  vec3 f = fract(p * CellDensity);	
  float res = 8.0;
  float md=8.0;
  vec3 mr;
  vec4 Out;
  for( int z=-1; z<=1; z++ )
  for( int y=-1; y<=1; y++ )
  for( int x=-1; x<=1; x++ )
  {
    vec3 lattice = vec3(x,y,z);
    vec3 offset=vhash(lattice + g ,AngleOffset);
    vec3 r = lattice +offset -f;
    float d = dot( r, r );
    if (d < res)
    {
      res=d;
      mr=r;
    }
  }

  res = 8.0;
  for( int z=-1; z<=1; z++ )
  for( int y=-1; y<=1; y++ )
  for( int x=-1; x<=1; x++ )
  {
    vec3 lattice = vec3(x,y,z);
    vec3 offset=vhash(lattice + g ,AngleOffset);
    vec3 r = lattice +offset -f;
    float d = dot( r, r );
    if( d < res )
    {
      res = d;
      Out.x= offset.x;
      Out.y =  d;
    }
    if( dot(mr-r,mr-r)>0.00001)
    {
      md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );
    }
  }
  Out.z = mix(1.0, 0.0, smoothstep( 0.0, 0.1, md ));
  Out.w = 1.0-smoothstep( 0.0, 0.1, res);
  return Out;
}

#if 0
#extension GL_NV_shader_buffer_load : enable
// tx should be range 0-1
f32 CosineInterpolatePointSet(f32 tx)
{
  /* Assert(Value <= 1.f); */
  /* Assert(Value >= 0.f); */

  // NOTE(Jesse): Descending order so we can scan from the front and find the interval we care about

  /* v2 Points[] = */
  /* { */
  /*   {{1.0f, 1.0f }}, */
  /*   {{0.7f, 0.85f }}, */
  /*   {{0.6f, 0.5f }}, */
  /*   {{0.3f, 0.4f }}, */
  /*   {{0.2f, 0.1f }}, */
  /*   {{0.0f, 0.0f }}, */
  /* }; */

  /* v2 Points[] = */
  /* { */
  /*   {{1.0f, 1.0f }}, */
  /*   {{0.5f, 0.7f }}, */
  /*   {{0.35f, 0.43f }}, */
  /*   {{0.3f, 0.4f }}, */
  /*   {{0.2f, 0.1f }}, */
  /*   {{0.0f, 0.0f }}, */
  /* }; */

  const s32 PointCount = 2;
  v2 Points[PointCount];
  Points[0] = v2(0.f, 0.0f);
  Points[1] = v2(1.0f, 1.0f);

  /* const s32 PointCount = 4; */
  /* v2 Points[PointCount]; */
  /* Points[3] = v2(0.0f, 0.0f); */
  /* Points[2] = v2(0.1f, 0.2f); */
  /* Points[1] = v2(0.8f, 1.0f); */
  /* Points[0] = v2(1.0f, 1.0f); */

  // Pretty nice

  /* s32 PointCount = 6; */
  /* v2 Points[6]; */
  /* Points[0] = v2(1.0f, 1.0f); */
  /* Points[1] = v2(0.7f, 0.7f); */
  /* Points[2] = v2(0.65f, 0.43f); */
  /* Points[3] = v2(0.6f, 0.4f); */
  /* Points[4] = v2(0.5f, 0.2f); */
  /* Points[5] = v2(0.0f, 0.1f); */

  // Pillar-y
  /* v2 Points[] = */
  /* { */
  /*   {{2.0f, 0.5f }}, */
  /*   {{0.6f, 0.3f }}, */
  /*   {{0.1f, 0.2f }}, */
  /*   {{0.05f, 0.45f }}, */
  /*   {{0.0f , 0.5f }}, */
  /* }; */

/*   v2 Points[] = */
/*   { */
/*     {{1.0f, 0.0f }}, */
/*     {{0.9f, 1.0f }}, */
/*     {{0.6f, 0.3f }}, */
/*     {{0.1f, 0.1f }}, */
/*     {{0.05f, 0.45f }}, */
/*     {{0.0f , 0.5f }}, */
/*   }; */



  r32 Result = Points[0].x;
  for (int PointIndex = 0; PointIndex < PointCount-1; ++PointIndex)
  {
    v2 P = Points[PointIndex];

    if (tx >= P.x)
    {
      v2 PNext = Points[PointIndex + 1];
      v2 Tmp = P;

      P = PNext;
      PNext = Tmp;

      r32 Range = PNext.x - P.x;
      r32 t = Clamp01((tx-P.x) / Range);
      Result = CosineInterpolate(t, P.y, PNext.y);
      /* Result = mix(P.y, PNext.y, t); */
      break;
    }
  }

  /* Result = abs(max(Result, 1.0)); */
  return Result;
}
#endif

void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 68);
  f32 y = floor(gl_FragCoord.y - (z*68));

  v3 Offset = V3(-2, -2, -2);
  v3 Basis = Offset + WorldspaceBasis + (v3(x,y,z)*ChunkResolution);


  // NOTE(Jesse): Set these in the -- user code -- section
  v3 ColorValue = V3(0.2f, 0.2f, 0.2f);
  f32 NoiseValue = 1.f;

  //
  // -- user code -- 
  //
  {
#if 1
    v3 Period = V3(200.f);
    float Amplitude = 150.f;
    f32 StartingZDepth = 0.f;

    NoiseValue = StartingZDepth;

    v3 xyz = Basis / Period;
    v4 gn = gradient_noise_derivs(xyz);

    /* NoiseValue += (CosineInterpolatePointSet((gn.x+1.f)/2.f)*2.f-1.f) * Amplitude; */
    NoiseValue += gn.x * Amplitude;

    /* NoiseValue += Smoothstep(pow(Clamp01(gn.x), 0.1)) * Amplitude; */

    f32 xyContrib = 0.2f*(max(abs(Basis.x), abs(Basis.y)));
    /* f32 xyContrib = 0.f; */
    NoiseValue -= Basis.z - xyContrib;
#endif
  }

  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;

  /* uint SolidBit = NoiseValue > 0.f ? 1u : 0u; */
  /* uint PackedColor = PackRGB(ColorValue); */
  /* /1* uint PackedColor = 3543u; *1/ */

  /* Output = (SolidBit << 15) | PackedColor; */
}
