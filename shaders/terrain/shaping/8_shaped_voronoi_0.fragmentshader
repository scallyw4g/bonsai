uniform  v2 SampleRemapCurvePoints[16];
uniform u32 SampleRemapCurvePointCount;

uniform v3 WorldspaceChunkBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;








uvec3 murmurHash33(uvec3 src) {
    const uint M = 0x5bd1e995u;
    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);
    src *= M; src ^= src>>24u; src *= M;
    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;
    h ^= h>>13u; h *= M; h ^= h>>15u;
    return h;
}

vec3 hash(vec3 src) {
    uvec3 h = murmurHash33(floatBitsToUint(src));
    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;
}

float sdLpDistance(in vec2 p, in float r, in float p_norm) {
    // (|x|^p + |y|^p)^(1/p)
    vec2 q = abs(p);
    float d = pow(pow(q.x, p_norm) + pow(q.y, p_norm), 1.0 / p_norm);
    return d - r;
}

vec2 get_point(vec2 pos) {
    ivec2 p = ivec2(floor(pos - 1.)) * 3;
    vec3 rng = hash(vec3(float(p.x), float(p.y), float(p.x + p.y)));
    return rng.xy;
}

const vec2 offsets[24] = vec2[24](
    vec2(-2, -2), vec2(-1, -2), vec2(0, -2), vec2(1, -2), vec2(2, -2),
    vec2(-2, -1), vec2(-1, -1), vec2(0, -1), vec2(1, -1), vec2(2, -1),
    vec2(-2, 0), vec2(-1, 0), vec2(1, 0), vec2(2, 0),
    vec2(-2, 1), vec2(-1, 1), vec2(0, 1), vec2(1, 1), vec2(2, 1),
    vec2(-2, 2), vec2(-1, 2), vec2(0, 2), vec2(1, 2), vec2(2, 2)
);

float sdShape(vec2 pos) {
    float p_norm = 3.25f;
    return sdLpDistance(pos, 0.9, p_norm);
}

float sdVoronoi(vec2 pos) {
    pos -= 0.5;
    vec2 p = fract(pos);
    
    vec2 nearest = get_point(pos);
    vec2 lastnearest = vec2(100.);
    vec2 current = vec2(0.);
    
    vec3 dists = vec3(
        sdShape(p - nearest),
        sdShape(p - lastnearest),
        sdShape(p - current)
    );
    
    for (int i = 0; i < 24; i++) {
        current = offsets[i];
        current += get_point(pos + offsets[i]);
        dists.z = sdShape(p - current);
        if (dists.z < dists.y) {
            dists.yz = dists.zy;
            lastnearest = current;
        }
        if (dists.y < dists.x) {
            dists.xy = dists.yx;
            lastnearest = nearest;
            nearest = current;
        }
    }
    
    float d = sdShape(p - lastnearest);
    return d;
}

float scene(vec2 p) {
    float d = sdVoronoi(p);
    return d;
}

/* vec4 noise( vec2 uv ) { */
/*   vec2 m = vec2(0,0); */
/*   float d = scene(uv); */

/*   vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0); */
/*   col *= 2.0 - exp(-6.0*abs(d)); */
/*   col *= 0.8 + 0.2*cos(150.0*d); */
/*   col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d))); */

/*   if(uv.x<0.)col = vec3(smoothstep(-1., 1., d)); */

/*   if (d<0.01 && d>0.){col = vec3(0.);} */

/*   v4 Result = vec4(col,d); */
/*   return Result; */
/* } */


v4 noise(vec2 uv)
{

    float d = scene(uv);
    v2 m = v2(0);


    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);
    col *= 1.0 - exp(-6.0 * abs(d));
    col *= 0.8 + 0.2 * cos(150.0 * d);
    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));
    
    if (uv.x < 0.) col = vec3(smoothstep(-1., 1., d));
    
    /* d = length(uv - m) - abs(scene(m)); */
    
    if (d < 0.01 && d > 0.) col = vec3(0.);
    
    v4 Result = vec4(col, d);
    return Result;
}


f32 ClampPositive(f32 Value)
{
  return Value < 0.f ? 0.f : Value;
}




void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 68);
  f32 y = floor(gl_FragCoord.y - (z*68));


  vec3 Offset = vec3(0);
  vec3 Basis = Offset + WorldspaceChunkBasis + (vec3(x,y,z)*ChunkResolution);


  // NOTE(Jesse): Set these in the -- user code -- section
  vec3 ColorValue = vec3(0.f);
  f32 NoiseValue = 0.f;

  //
  // -- user code --
  //
  {
    f32 StartingZDepth = 800.f;
    NoiseValue += StartingZDepth - Basis.z;

    f32 CliffMask = 1.f;
    {
      vec3 Period = vec3(250.f);
      /* vec3 Period = vec3(10.f); */
      float Amplitude = 200.f;

      vec3 xyz = Basis / Period;
      v4 N = noise(xyz.xy);

      /* N.w *= -1.f; */
      /* N.w = ClampPositive(N.w); */

      N.w = (N.w/2.f)+0.5f;

      N.w = RemapSample(N.w, SampleRemapCurvePoints, SampleRemapCurvePointCount );

      NoiseValue += ClampPositive(N.w * Amplitude);
      ColorValue = N.rgb;
    }

  }

  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
