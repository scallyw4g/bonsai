uniform v3 WorldspaceBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;




f32
MapNoiseValueToFinal(f32 Value)
{
  /* Assert(Value <= 1.f); */
  /* Assert(Value >= 0.f); */

  // NOTE(Jesse): Descending order so we can scan from the front and find the interval we care about

  /* v2 Points[] = */
  /* { */
  /*   {{1.0f, 1.0f }}, */
  /*   {{0.7f, 0.85f }}, */
  /*   {{0.6f, 0.5f }}, */
  /*   {{0.3f, 0.4f }}, */
  /*   {{0.2f, 0.1f }}, */
  /*   {{0.0f, 0.0f }}, */
  /* }; */

  /* v2 Points[] = */
  /* { */
  /*   {{1.0f, 1.0f }}, */
  /*   {{0.5f, 0.7f }}, */
  /*   {{0.35f, 0.43f }}, */
  /*   {{0.3f, 0.4f }}, */
  /*   {{0.2f, 0.1f }}, */
  /*   {{0.0f, 0.0f }}, */
  /* }; */

  const s32 PointCount = 2;
  v2 Points[PointCount];
  Points[0] = v2(1.0f, 1.0f);
  Points[1] = v2(0.f, 0.0f);

  // Pretty nice

/*   s32 PointCount = 6; */
/*   v2 Points[6]; */
/*   Points[0] = v2(1.0f, 1.0f); */
/*   Points[1] = v2(0.7f, 0.7f); */
/*   Points[2] = v2(0.65f, 0.43f); */
/*   Points[3] = v2(0.6f, 0.4f); */
/*   Points[4] = v2(0.5f, 0.2f); */
/*   Points[5] = v2(0.0f, 0.1f); */

  // Pillar-y
  /* v2 Points[] = */
  /* { */
  /*   {{2.0f, 0.5f }}, */
  /*   {{0.6f, 0.3f }}, */
  /*   {{0.1f, 0.2f }}, */
  /*   {{0.05f, 0.45f }}, */
  /*   {{0.0f , 0.5f }}, */
  /* }; */

/*   v2 Points[] = */
/*   { */
/*     {{1.0f, 0.0f }}, */
/*     {{0.9f, 1.0f }}, */
/*     {{0.6f, 0.3f }}, */
/*     {{0.1f, 0.1f }}, */
/*     {{0.05f, 0.45f }}, */
/*     {{0.0f , 0.5f }}, */
/*   }; */



  r32 Result = Value;
  for (int PointIndex = 0; PointIndex < PointCount-1; ++PointIndex)
  {
    v2 P = Points[PointIndex];

    // This is sort of a hack to fix the degenerate case when the value is 0 or 1.
    // TODO(Jesse): Make this branchless
    if (Value == P.x) return P.y;

    if (Value > P.x)
    {
      v2 PNext = Points[PointIndex + 1];

      r32 Range = PNext.x - P.x;
      r32 t = (Value-P.x) / Range;
      Result = mix(t, P.y, PNext.y);
      break;
    }
  }

  Result = abs(max(Result, 1.0));
  return Result;
}

f32
RoundToNearestMultiple(f32 NumToRound, f32 Multiple)
{
  f32 Remainder = mod(NumToRound, Multiple);
  if (Remainder == 0)
    return NumToRound;

  return NumToRound + Multiple - Remainder;
}

void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 66);
  f32 y = floor(gl_FragCoord.y - (z*66));

  /* v3 Offset = V3(-1, -1, -1); */
  v3 Offset = V3(0);
  v3 Basis = Offset + WorldspaceBasis + (v3(x,y,z)*ChunkResolution);

#if 0
  {
    v3 TileCoord = trunc(Basis/16.f);
    TileCoord.z = 0.f;
    f32 TileNoise = white_noise(TileCoord);

    f32 zMod = mod(Basis.z, 16.f)/16.f;

    f32 Soften = clamp(zMod-0.4f, 0.f, 1.f)*16.f;

    Basis.z = Basis.z - zMod + Soften; //+ TileNoise;
  }
#endif

#if 0
  Basis.z = RoundToNearestMultiple(Basis.z, 16.f);
#endif

  // NOTE(Jesse): Set these in the -- user code -- section
  v3 ColorValue = V3(0.f);
  f32 NoiseValue = 0.f;

  //
  // -- user code -- 
  //
  {
    v3 Period = V3(1500.f);
    float Amplitude = 100.f;
    f32 StartingZDepth = 10000;
    /* f32 StartingZDepth = 0; */
    s32 Octaves = 6;
    NoiseValue = StartingZDepth;

#if 1
    {
      f32 Start = 8000;
      f32 End = 10000;
      f32 Width = End-Start;
      f32 Rad = Width/2.f;
      /* f32 Power = 2000.f; */
      /* f32 Power = 0.001f; */
      f32 Power = 1000.f;

      f32 CircleOrigin = Start + Rad;

      /* if (Basis.x > Start && Basis.y > Start && */
      /*     Basis.x < End && Basis.y < End) */
      {
        v2 OriginRelativeBasis = 0.30f*((Basis.xy-CircleOrigin)/Rad);
        /* v2 t = sin(PI32*(0.5f+(OriginRelativeBasis/Width))); */
        /* f32 t = sin(PI32*max(0.f, Rad - length(OriginRelativeBasis))); */
        f32 t = sin( Rad - length(OriginRelativeBasis));
        /* NoiseValue += min(t.x*Power, t.y*Power); */
        NoiseValue += t*Power;
      }
    }
#endif

    v3 Deriv = v3(0.f);
    f32 warp = 0.f;

    for (s32 Octave = 1; Octave <= Octaves; ++Octave)
    {
      v3 xyz = Basis / (Period/Octave);

      v4 gn = gradient_noise_derivs(xyz+warp);
      NoiseValue += gn.x*(Amplitude/Octave);
      Deriv += gn.yzw;
    }

    v3 Up = V3(0, 0, 1);

    /* NoiseValue = 100.f+MapNoiseValueToFinal(NoiseValue); */

    Deriv = normalize(Deriv);
    /* Deriv.xy = abs(Deriv.xy); */
    f32 Cliffness = clamp(dot(Deriv, Up), 0.f, 1.f);
    f32 Grassness = clamp(.15f-Cliffness, 0.f, 1.f);

    ColorValue = mix(v3(.1,.8,.2), v3(.3), Cliffness);
    /* ColorValue = mix(v3(.1,.8,.2), v3(.3), pow(Cliffness, .2)); */
    /* ColorValue = Cliffness > 0.15f ? V3(0.3f) : v3(.1,.8,.2); */

    // Grassy ripples
    {
      v4 gWobble = gradient_noise_derivs(Basis/v3(30, 30, 80));
      NoiseValue += gWobble.x*Grassness*50;
      ColorValue += V3(0.f, 1.f, 0.f)*gWobble.x*Grassness*1.5f;
    }


#if 1
    f32 rng2d = white_noise(Basis.xy);
    f32 rng3d = white_noise(Basis);

    v3 BaseCliffColor = V3(0.08f);
    v3 CliffColor = BaseCliffColor;
    f32 CliffValue = 0.f;
    // Main cliffs
    {
      v3 v = voronoi_noise(Basis/v3(200,200,1800));
      CliffValue += (v.x*200)*Cliffness;
      CliffValue += (v.y*25)*Cliffness;
      CliffColor = mix(CliffColor, BaseCliffColor, clamp(10*Cliffness*v.x,0,1));
    }
    {
      v3 v = voronoi_noise(Basis/v3(100,100,600));
      v.x += 0.5f;
      v.x = v.x*v.x;

      if (v.x > 0.28f)
      {
        CliffValue += (v.x*25)*Cliffness;
        /* CliffValue += (v.y*10)*Cliffness; */
        CliffColor = mix(CliffColor, v3(.7), Cliffness*v.x);
      }
    }
    {
      v3 v = voronoi_noise(Basis/v3(50,50,200));
      v.x += 0.50f;
      v.x = v.x * v.x;

      if (v.x > 0.30)
      {
        /* CliffValue += (v.x)*Cliffness; */
        CliffValue += (v.x*10)*pow(Cliffness,3);
        CliffColor = mix(CliffColor, v3(.9), Cliffness*v.x*v.x);
      }
    }
    {
      CliffValue += rng3d * 0.1f;
      CliffColor = mix(CliffColor, v3(1.f), rng3d*Cliffness*.2);
    }

    if (CliffValue > 12.f)
    {
      NoiseValue += CliffValue;
      ColorValue = CliffColor;
    }


    f32 gravel_patch_stregth  = value_noise_derivs(150+(Basis/300)).x;
        gravel_patch_stregth += value_noise_derivs(150+(Basis/160)).x;
        gravel_patch_stregth += value_noise_derivs(150+(Basis/80)).x;
        gravel_patch_stregth += value_noise_derivs(150+(Basis/40)).x;
        gravel_patch_stregth += value_noise_derivs(150+(Basis/20)).x;
        gravel_patch_stregth += value_noise_derivs(150+(Basis/8)).x;
        gravel_patch_stregth = max(gravel_patch_stregth, 0.f);


    // Grass & Flowers
    {
      f32 n = clamp(rng2d-0.7f, 0.f, 1.f);

      f32 GrassValue = 90*n*Grassness;

      f32 tFlower = Basis.z - (GrassValue + NoiseValue);
          tFlower = max(tFlower, 0);


    f32 grass_patch_stregth  = value_noise_derivs(Basis/80).x;
        grass_patch_stregth += value_noise_derivs(Basis/40).x;
        grass_patch_stregth += value_noise_derivs(Basis/20).x;
        grass_patch_stregth += value_noise_derivs(Basis/8).x;
        grass_patch_stregth = max(grass_patch_stregth-gravel_patch_stregth, 0.f);

      NoiseValue += GrassValue*grass_patch_stregth;

      f32 tColor = (grass_patch_stregth / 2.f)*Grassness;
      ColorValue = mix(ColorValue, V3(.6f, .8f, .1f), tColor);

      if (rng2d > 0.99f)
      {
        ColorValue = mix(ColorValue, V3(.5f, .5f, .5f), tFlower);
      }
      if (rng2d > 0.995f)
      {
        ColorValue = mix(ColorValue, V3(.5f, .2f, .5f), tFlower);
      }


      /* ColorValue *= tFlower; */

      /* ColorValue = V3(tFlower); */
      /* ColorValue = V3(GrassValue/1.f); */
    }

    // Rocky edges
    {
      f32 MinDotValue = 0.6f;
      v3 v = voronoi_noise(Basis/v3(20,20,20));
      f32 Power = 100*gravel_patch_stregth*Cliffness*abs(clamp(Cliffness-MinDotValue, -MinDotValue, 0));
      if (v.x*Power > 3.f)
      {
        NoiseValue += v.x*Power;
        ColorValue = v3(1.0);
      }
    }
    /* { */
    /*   f32 MinDotValue = 0.4f; */
    /*   v3 v = voronoi_noise(Basis/v3(10,10,10)); */
    /*   f32 Power = 400*gravel_patch_stregth*Cliffness*abs(clamp(Cliffness-MinDotValue, -MinDotValue, 0)); */
    /*   NoiseValue += v.x*Power; */
    /*   /1* NoiseValue -= ((1.f/v.x)*2)*Power; *1/ */
    /*   ColorValue = mix(ColorValue, v3(1.0), Power/3*v.x); */
    /* } */


    /* ColorValue = V3(Grassness, Cliffness, 0.f); */
    /* ColorValue = V3(Cliffness); */

    // Bias noise value to lower values as we get higher in z.
    // This creates a "plane" of terrain
    /* NoiseValue = NoiseValue - Basis.z + sin(Basis.x/500.f)*1000.f; */
    /* NoiseValue = NoiseValue - Basis.z + sin(Basis.x/500.f)*300.f - cos(Basis.y/800.f)*200.f;; */
    NoiseValue = NoiseValue - Basis.z;

#if 0
    if (NoiseValue <= 0)
    {
      v3 TileCoord = trunc(Basis/16.f);
      TileCoord.z = 0.f;

      f32 TileNoise = white_noise(TileCoord)*14.f;

      f32 NoiseToTile = TileNoise - NoiseValue;
          NoiseToTile = clamp(NoiseToTile, -1, 1);

      NoiseValue += NoiseToTile;
    }
#endif
#endif

    /* NoiseValue = StartingZDepth; */

  }

  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;

  /* uint SolidBit = NoiseValue > 0.f ? 1u : 0u; */
  /* ColorValue = min(ColorValue, v3(1.f)); */
  /* uint PackedColor = PackRGB(ColorValue); */
  /* /1* uint PackedColor = 3543u; *1/ */

  /* Output = (SolidBit << 15) | PackedColor; */
}
