uniform  v2 SampleRemapCurvePoints[16];
uniform u32 SampleRemapCurvePointCount;

uniform v3 WorldspaceChunkBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;

void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 68);
  f32 y = floor(gl_FragCoord.y - (z*68));


  v3 Offset = V3(0);
  v3 Basis = Offset + WorldspaceChunkBasis + (v3(x,y,z)*ChunkResolution);


  v3 ColorValue = V3(0.1f);

  f32 NoiseValue = 500.f-Basis.z;

#if 1
  ColorValue = V3(0.008f, 0.05f, 0.008f)*2.f;

  f32 White = white_noise(v3(x,y,z));
  ColorValue -= 0.01f*White;
#endif

#if 1
  {
    v3 Period = V3(80.f);
    float Amplitude = 40.f;
    v3 xyz = Basis / Period;
    v4 gn = gradient_noise_derivs(xyz);
    NoiseValue += gn.x * Amplitude;
  }
#endif


#if 1
  {
    v3 Period = V3(180.f, 180.f, 300.f);
    float Amplitude = 300.f;
    v3 xyz = Basis / Period;

    f32 f = Square(gradient_noise_derivs(xyz).x);
    /* f32 f = gradient_noise_derivs(xyz).x; */
    /* f32 f = gradient_noise_derivs(V3(xyz.xy,0.f)).x; */
    f = RemapSample((1.f+f)/2.f, SampleRemapCurvePoints, SampleRemapCurvePointCount);

    NoiseValue += f * Amplitude;
  }
#endif


  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;
}
