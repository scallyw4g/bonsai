uniform  v2 SampleRemapCurvePoints[16];
uniform u32 SampleRemapCurvePointCount;

uniform v3 WorldspaceChunkBasis;
uniform v3 ChunkResolution;

in vec2 UV;
out v4 Output;

void main()
{
  f32 x = floor(gl_FragCoord.x);
  f32 z = floor(gl_FragCoord.y / 68);
  f32 y = floor(gl_FragCoord.y - (z*68));

  v3 Offset = V3(0);
  v3 Basis = Offset + WorldspaceChunkBasis + (v3(x,y,z)*ChunkResolution);

  // NOTE(Jesse): Set these in the -- user code -- section
  v3 ColorValue = V3(0.1f, 0.7f, 0.1f);
  f32 NoiseValue = 0.f;

  //
  // -- user code -- 
  //
  {
    v3 Period = V3(800.f);
    float Amplitude = 800.f;
    /* f32 StartingZDepth = 10000; */
    f32 StartingZDepth = 15000;
    /* f32 StartingZDepth = 0; */
    NoiseValue = StartingZDepth;

    v3 Deriv = v3(0.f);
    /* f32 warp = 0.f; */

    /* v3 warp = v3(gradient_noise_derivs(Basis).x); */
    v3 warp = v3(0.f);

    {
      v3 xyz = Basis / (12000.f);
      /* v3 N = voronoi_noise(xyz+warp); */
      f32 Mask = (gradient_noise_derivs(Basis/20000.f).x+1.f)/2.f;
          /* Mask = RemapSample(Mask, SampleRemapCurvePoints, SampleRemapCurvePointCount ); */
      f32 N = ridge_noise(xyz+warp)*Mask;
      /* NoiseValue += RemapSample((N+1.f)/2.f, SampleRemapCurvePoints, SampleRemapCurvePointCount ) * 10000.f; */
      NoiseValue += N * 20000.f;
    }

    /* { */
    /*   v3 xyz = Basis / (15000.f); */
    /*   /1* v3 N = voronoi_noise(xyz+warp); *1/ */
    /*   v4 N = gradient_noise_derivs(xyz+warp); */
    /*   NoiseValue += RemapSample((N.x+1.f)/2.f, SampleRemapCurvePoints, SampleRemapCurvePointCount ) * 10000.f; */
    /*   /1* NoiseValue += N.x * 20000.f; *1/ */
    /* } */

    /* { */
    /*   v3 xyz = Basis / (Period); */
    /*   v4 N = gradient_noise_derivs(xyz+warp); */
    /*   NoiseValue += RemapSample((N.x+1.f)/2.f, SampleRemapCurvePoints, SampleRemapCurvePointCount ) * Amplitude; */
    /* } */

    /* s32 Octaves = 4; */
    /* f32 B = 0.f; */
    /* for (s32 Octave = 1; Octave <= Octaves; ++Octave) */
    /* { */
    /*   v3 xyz = Basis / (Period/Octave); */
    /*   f32 N = billow_noise(xyz+warp); */
    /*   B = max(N, B); */
    /*   /1* NoiseValue += RemapSample((N.x+1.f)/2.f, SampleRemapCurvePoints, SampleRemapCurvePointCount )*(Amplitude/Octave); *1/ */
    /* } */
    /* NoiseValue += B * Amplitude; */

    v3 Up = V3(0, 0, 1);

    NoiseValue -= Basis.z;
    /* NoiseValue = StartingZDepth; */

  }

  //
  // -- end user code --
  //

  Output.rgb = ColorValue;
  Output.a = NoiseValue;

  /* Output = (SolidBit << 15) | PackedColor; */
}
