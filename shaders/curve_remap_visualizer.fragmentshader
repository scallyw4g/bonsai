/* #extension GL_NV_shader_buffer_load : enable */

uniform v2 Points[16];
uniform u32 Count;

in vec2 UV;
out v4 Output;


b32
WithinTolerance(f32 Epsilon, f32 A, f32 B)
{
  b32 Result = (A+Epsilon > B && A-Epsilon < B);
  return Result;
}


f32 Remap(f32 SampleX, v2 Points[16], u32 PointCount )
{

  f32 Result = -1.f;
  v2 PrevP = Points[0];
  for (u32 PointIndex = 1u; PointIndex < PointCount; ++PointIndex)
  {
    v2 NextP = Points[PointIndex];

    if (SampleX >= PrevP.x && SampleX < NextP.x)
    {


      r32 Range = PrevP.x - NextP.x;
      r32 t = Clamp01((SampleX-NextP.x) / Range);

      Result = CosineInterpolate(t, NextP.y, PrevP.y);

      /* Result = mix(NextP.y, PrevP.y, t); */

      /* Result = QuinticInterpolate(Result); */
      /* Result = QuinticInterpolate(Result); */

      /* Result = CubicInterpolate(Result); */
      /* Result = Smoothstep(Result); */
      /* Result = Smoothstep(Result); */

      break;
    }

    PrevP = NextP;
  }

  /* Result = abs(max(Result, 1.0)); */
  return Result;
}
void main()
{
  Output = V4(1,1,1,1);


  f32 Mapped = Remap(UV.x, Points, Count);

  if (Mapped == -1.f)
  {
    Output.rgb = v3(1.0f, 0.f, 1.0f);
  }
  else
  {
    r32 ThicknessInUVCoordinates = 0.01f;
#if 0
    if (Mapped > UV.y)
    {
      Output.rgb = V3(0.2);
    }
#else
    if (WithinTolerance(0.01f, Mapped, UV.y))
    {
      r32 Dist = abs(UV.y - Mapped);

      r32 t = Dist/ThicknessInUVCoordinates;
      Output.rgb = mix(v3(0), V3(1), t);
    }
#endif
  }

}
