layout(location = VERTEX_POSITION_LAYOUT_LOCATION) in vec3 vertexPosition_modelspace;
layout(location =   VERTEX_NORMAL_LAYOUT_LOCATION) in vec3 vertexNormal_modelspace;
layout(location = VERTEX_MATERIAL_LAYOUT_LOCATION) in uint vertexMaterial; // NOTE(Jesse): 16-bits Color, 8 bits transparency, 8 bits emission
/* layout(location = VERTEX_TRANS_EMISS_LAYOUT_LOCATION) in vec2 in_TransEmiss; // NOTE(Jesse): 8-bit */

out vec3 vertexP_worldspace;
out vec3 vertexN_worldspace;
out vec3 MaterialColor;
out vec2 TransEmiss;

uniform vec3 OffsetOfWorldCenterToGrid;
uniform vec3 CameraToWorld;
uniform mat4 ModelMatrix;
uniform mat4 ViewProjection;

uniform sampler2D ColorPalette;



// TODO(Jesse): Pass in a m3 here.  I didn't have an m3 struct, so I didn't
// bother, but I should do that at some point..
//
uniform mat4 NormalMatrix; // Inverted and transposed ModelMatrix.

void main()
{
  uint Transparency = uint((vertexMaterial>>16) & 0xFFu);
  uint Emission     = uint((vertexMaterial>>8)  & 0xFFu);
  uint ColorIndex   = uint((vertexMaterial)     & 0xFFFFu);

  MaterialColor = texelFetch(ColorPalette, ivec2(ColorIndex, 0), 0).rgb;
  /* TransEmiss = V2(in_TransEmiss[0], in_TransEmiss[1]); */
  TransEmiss = V2(0.5f, 0.5f);

  v4 ModelVertex = ModelMatrix*vec4(vertexPosition_modelspace, 1);

  vertexP_worldspace = ModelVertex.xyz;
  vertexN_worldspace = mat3(NormalMatrix) * vertexNormal_modelspace;

  gl_Position =  ViewProjection * ModelVertex;
}

