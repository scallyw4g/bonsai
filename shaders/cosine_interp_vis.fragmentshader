in vec2 UV;
out v4 Output;



f32
MapNoiseValueToFinal(f32 Value)
{
  // NOTE(Jesse): Descending order so we can scan from the front and find the interval we care about
  /* v2 Points[] = */
  /* { */
  /*   {{1.0f, 1.0f }}, */
  /*   {{0.7f, 0.85f }}, */
  /*   {{0.6f, 0.5f }}, */
  /*   {{0.3f, 0.4f }}, */
  /*   {{0.2f, 0.1f }}, */
  /*   {{0.0f, 0.0f }}, */
  /* }; */

  /* v2 Points[] = */
  /* { */
  /*   {{1.0f, 1.0f }}, */
  /*   {{0.5f, 0.7f }}, */
  /*   {{0.35f, 0.43f }}, */
  /*   {{0.3f, 0.4f }}, */
  /*   {{0.2f, 0.1f }}, */
  /*   {{0.0f, 0.0f }}, */
  /* }; */

  const s32 PointCount = 3;
  v2 Points[PointCount];

  /* Points[0] = v2(1.0f, 1.0f); */
  /* Points[1] = v2(0.f, 0.0f); */


  // Steep

  Points[0] = v2(1.0f, 1.0f);
  Points[1] = v2(0.5f, 0.85f);
  Points[2] = v2(0.0f, 0.0f);

  // Pretty nice

  /* Points[0] = v2(1.0f, 1.0f); */
  /* Points[1] = v2(0.7f, 0.7f); */
  /* Points[2] = v2(0.65f, 0.43f); */
  /* Points[3] = v2(0.6f, 0.4f); */
  /* Points[4] = v2(0.5f, 0.2f); */
  /* Points[5] = v2(0.0f, 0.1f); */

  // Pillar-y

    /* Points[0] = v2(2.0f, 0.5f); */
    /* Points[1] = v2(0.6f, 0.3f); */
    /* Points[2] = v2(0.1f, 0.2f); */
    /* Points[3] = v2(0.05f, 0.45f); */
    /* Points[4] = v2(0.0f , 0.5f); */

/*   v2 Points[] = */
/*   { */
/*     {{1.0f, 0.0f }}, */
/*     {{0.9f, 1.0f }}, */
/*     {{0.6f, 0.3f }}, */
/*     {{0.1f, 0.1f }}, */
/*     {{0.05f, 0.45f }}, */
/*     {{0.0f , 0.5f }}, */
/*   }; */



  r32 Result = Value;
  for (int PointIndex = 0; PointIndex < PointCount-1; ++PointIndex)
  {
    v2 P = Points[PointIndex];

    // This is sort of a hack to fix the degenerate case when the value is 0 or 1.
    // TODO(Jesse): Make this branchless
    if (Value == P.x) return P.y;

    if (Value > P.x)
    {
      v2 PNext = Points[PointIndex + 1];

      r32 Range = PNext.x - P.x;
      r32 t = (Value-P.x) / Range;
      Result = mix(t, P.y, PNext.y);
      break;
    }
  }

  Result = abs(max(Result, 1.0));
  return Result;
}

f32
RoundToNearestMultiple(f32 NumToRound, f32 Multiple)
{
  f32 Remainder = mod(NumToRound, Multiple);
  if (Remainder == 0)
    return NumToRound;

  return NumToRound + Multiple - Remainder;
}

b32
WithinTolerance(f32 Epsilon, f32 A, f32 B)
{
  b32 Result = (A+Epsilon > B && A-Epsilon < B);
  return Result;
}


void main()
{
  Output = V4(1,1,1,1);


  f32 Mapped = MapToFinal(UV.x);

  if (Mapped == -1.f)
  {
    Output.rgb = v3(1.0f, 0.f, 1.0f);
  }
  else
  {
    if (WithinTolerance(0.01f, Mapped, UV.y))
    {
      Output.rgb = v3(0.2f, 0.2f, 0.2f);
    }
  }

}
